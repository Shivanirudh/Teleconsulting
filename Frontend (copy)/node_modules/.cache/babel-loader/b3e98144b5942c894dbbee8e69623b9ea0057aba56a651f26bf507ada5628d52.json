{"ast":null,"code":"import { errorPrefix } from \"@tsparticles/engine\";\nconst double = 2,\n  defaultAlpha = 1,\n  sides = 12,\n  defaultRatio = 1;\nexport class ImageDrawer {\n  constructor(engine) {\n    this.loadImageShape = async imageShape => {\n      if (!this._engine.loadImage) {\n        throw new Error(`${errorPrefix} image shape not initialized`);\n      }\n      await this._engine.loadImage({\n        gif: imageShape.gif,\n        name: imageShape.name,\n        replaceColor: imageShape.replaceColor ?? false,\n        src: imageShape.src\n      });\n    };\n    this._engine = engine;\n  }\n  addImage(image) {\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    this._engine.images.push(image);\n  }\n  async draw(data) {\n    const {\n        context,\n        radius,\n        particle,\n        opacity\n      } = data,\n      image = particle.image,\n      element = image?.element;\n    if (!image) {\n      return;\n    }\n    context.globalAlpha = opacity;\n    if (image.gif && image.gifData) {\n      const {\n        drawGif\n      } = await import(\"./GifUtils/Utils.js\");\n      drawGif(data);\n    } else if (element) {\n      const ratio = image.ratio,\n        pos = {\n          x: -radius,\n          y: -radius\n        },\n        diameter = radius * double;\n      context.drawImage(element, pos.x, pos.y, diameter, diameter / ratio);\n    }\n    context.globalAlpha = defaultAlpha;\n  }\n  getSidesCount() {\n    return sides;\n  }\n  async init(container) {\n    const options = container.actualOptions;\n    if (!options.preload || !this._engine.loadImage) {\n      return;\n    }\n    for (const imageData of options.preload) {\n      await this._engine.loadImage(imageData);\n    }\n  }\n  async loadShape(particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    const imageData = particle.shapeData;\n    if (!imageData) {\n      return;\n    }\n    const image = this._engine.images.find(t => t.name === imageData.name || t.source === imageData.src);\n    if (!image) {\n      await this.loadImageShape(imageData);\n      await this.loadShape(particle);\n    }\n  }\n  async particleInit(container, particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    const images = this._engine.images,\n      imageData = particle.shapeData;\n    if (!imageData) {\n      return;\n    }\n    const color = particle.getFillColor(),\n      image = images.find(t => t.name === imageData.name || t.source === imageData.src);\n    if (!image) {\n      return;\n    }\n    const replaceColor = imageData.replaceColor ?? image.replaceColor;\n    if (image.loading) {\n      setTimeout(() => {\n        void this.particleInit(container, particle);\n      });\n      return;\n    }\n    let imageRes;\n    if (image.svgData && color) {\n      const {\n        replaceImageColor\n      } = await import(\"./Utils.js\");\n      imageRes = await replaceImageColor(image, imageData, color, particle);\n    } else {\n      imageRes = {\n        color,\n        data: image,\n        element: image.element,\n        gif: image.gif,\n        gifData: image.gifData,\n        gifLoopCount: image.gifLoopCount,\n        loaded: true,\n        ratio: imageData.width && imageData.height ? imageData.width / imageData.height : image.ratio ?? defaultRatio,\n        replaceColor: replaceColor,\n        source: imageData.src\n      };\n    }\n    if (!imageRes.ratio) {\n      imageRes.ratio = 1;\n    }\n    const fill = imageData.fill ?? particle.shapeFill,\n      close = imageData.close ?? particle.shapeClose,\n      imageShape = {\n        image: imageRes,\n        fill,\n        close\n      };\n    particle.image = imageShape.image;\n    particle.shapeFill = imageShape.fill;\n    particle.shapeClose = imageShape.close;\n  }\n}","map":{"version":3,"names":["errorPrefix","double","defaultAlpha","sides","defaultRatio","ImageDrawer","constructor","engine","loadImageShape","imageShape","_engine","loadImage","Error","gif","name","replaceColor","src","addImage","image","images","push","draw","data","context","radius","particle","opacity","element","globalAlpha","gifData","drawGif","ratio","pos","x","y","diameter","drawImage","getSidesCount","init","container","options","actualOptions","preload","imageData","loadShape","shape","shapeData","find","t","source","particleInit","color","getFillColor","loading","setTimeout","imageRes","svgData","replaceImageColor","gifLoopCount","loaded","width","height","fill","shapeFill","close","shapeClose"],"sources":["/home/aksh2002/Desktop/Teleconsulting/node_modules/@tsparticles/shape-image/browser/ImageDrawer.js"],"sourcesContent":["import { errorPrefix } from \"@tsparticles/engine\";\nconst double = 2, defaultAlpha = 1, sides = 12, defaultRatio = 1;\nexport class ImageDrawer {\n    constructor(engine) {\n        this.loadImageShape = async (imageShape) => {\n            if (!this._engine.loadImage) {\n                throw new Error(`${errorPrefix} image shape not initialized`);\n            }\n            await this._engine.loadImage({\n                gif: imageShape.gif,\n                name: imageShape.name,\n                replaceColor: imageShape.replaceColor ?? false,\n                src: imageShape.src,\n            });\n        };\n        this._engine = engine;\n    }\n    addImage(image) {\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        this._engine.images.push(image);\n    }\n    async draw(data) {\n        const { context, radius, particle, opacity } = data, image = particle.image, element = image?.element;\n        if (!image) {\n            return;\n        }\n        context.globalAlpha = opacity;\n        if (image.gif && image.gifData) {\n            const { drawGif } = await import(\"./GifUtils/Utils.js\");\n            drawGif(data);\n        }\n        else if (element) {\n            const ratio = image.ratio, pos = {\n                x: -radius,\n                y: -radius,\n            }, diameter = radius * double;\n            context.drawImage(element, pos.x, pos.y, diameter, diameter / ratio);\n        }\n        context.globalAlpha = defaultAlpha;\n    }\n    getSidesCount() {\n        return sides;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!options.preload || !this._engine.loadImage) {\n            return;\n        }\n        for (const imageData of options.preload) {\n            await this._engine.loadImage(imageData);\n        }\n    }\n    async loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            await this.loadImageShape(imageData);\n            await this.loadShape(particle);\n        }\n    }\n    async particleInit(container, particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const images = this._engine.images, imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        const replaceColor = imageData.replaceColor ?? image.replaceColor;\n        if (image.loading) {\n            setTimeout(() => {\n                void this.particleInit(container, particle);\n            });\n            return;\n        }\n        let imageRes;\n        if (image.svgData && color) {\n            const { replaceImageColor } = await import(\"./Utils.js\");\n            imageRes = await replaceImageColor(image, imageData, color, particle);\n        }\n        else {\n            imageRes = {\n                color,\n                data: image,\n                element: image.element,\n                gif: image.gif,\n                gifData: image.gifData,\n                gifLoopCount: image.gifLoopCount,\n                loaded: true,\n                ratio: imageData.width && imageData.height\n                    ? imageData.width / imageData.height\n                    : image.ratio ?? defaultRatio,\n                replaceColor: replaceColor,\n                source: imageData.src,\n            };\n        }\n        if (!imageRes.ratio) {\n            imageRes.ratio = 1;\n        }\n        const fill = imageData.fill ?? particle.shapeFill, close = imageData.close ?? particle.shapeClose, imageShape = {\n            image: imageRes,\n            fill,\n            close,\n        };\n        particle.image = imageShape.image;\n        particle.shapeFill = imageShape.fill;\n        particle.shapeClose = imageShape.close;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}